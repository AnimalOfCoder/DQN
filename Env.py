import numpy as np
from Slice1 import Slice1 
from Reservation import Reservation 
from Slice2 import Slice2
from DQNd import DQNd
from initialVR2 import initialVR2

'''
    This is used to check whether the users randomly generated by the slices
    are feasible in their resource requirement. they are first admited to the network using MAX SINR, 
    if fully accepted their accept=1 for that users else accept=0, 
    user is addmited in this case does not mean the users must have resource
    allocation from that base station only, it is used only for checking if
    the resource is enouph for all users. if res=0 is returned the slice is accepted, if res is non zero it will be
    ID of the slice 
    V is the resource vector in the slices occupied by the slice, 
    accept is a vector of of 0 and 1 that indicate whether the corresponding user of the slice is accepted or not
    rtV is a matrix of achievable data rates of the users of the slice in all hte base stations,
    Q is minimum resource requirement of the users
'''
def initialVR(rtV, Q):
    [S,un] = Reservation.getUnusedResourceAndNumOfSlices()
    [K,B] = np.array(rtV).shape
    qyu = np.zeros((K,B))
    for i in range(0, K):
        for j in range(0, B):
            qyu[i,j]=Q[1,i]/rtV[i,j]# how much fractions is required by the users in each bs assuming single user base station associations
    #calculate the resource requitement of the slice in the BSs assumig every user is admitted sequencially as they come to the nearest BS
    VR=np.zeros((1, B))
    accepF=np.zeros((1, K))#how much percent of the user is accepted
    copyr=rtV
    wh=0
    while wh <= K*B:
        maxr=max(max(copyr))# the smallest user bs distance combination
        for i in range(0, K):
            for m in range(0, B):
                if copyr[i,m]==maxr and (accepF[0,i]+1) !=2: # plus one is used to ignore very small fraction
                    if un[1,m]>=qyu[i,m]*(1-accepF[0,i]) and qyu[i,m]>0 and un[1,m]>0:
                        VR[0,m]=VR[0,m]+qyu[i,m] * (1-accepF[0,i])
                        un[1,m]=un[1,m]-qyu[i,m] * (1-accepF[0,i])
                        accepF[0,i]=1
                    elif un[1,m]<qyu[i,m]*(1-accepF[0,i]) and  qyu[i,m]>0 and un[1,m]>0:
                        VR[0,m]=VR[0,m]+un[1,m]
                        un[1,m]=0
                        accepF[0,i]=accepF[0,i]+un[1,m]/(qyu[i,m]*(1-accepF[0,i]))

                    copyr[i,m]=0
        
        if max(max(copyr))==0 or min(accepF)==1:
            break

        wh=wh+1
    
    # now the virtual resource is for the users that are fully accepted
    accept=np.floor(accepF)
    if sum(accept)>=1: # check if there is at leasst one user fully accepted
        S, _ = Reservation.getUnusedResourceAndNumOfSlices() 
        res=S+1
        V=VR
        RQ=np.zeros((1,B))
        reser = Reservation(res,np.zeros((1,B)), RQ, 0)
        reser.initialization()
    else:
        res=0 # reject the slice. no enouph resource
        V=np.zeros((1,B))


    return res, V, accept



# sliceboth
def run():
    for T in range(0, 100000):
        '''
        s1r a vector of achievable data rate of users of slice1
        s1Q is a vector of minimum QoS requirements of users of slice1
        s1ar is a vector of arrival rates of users of slice1, a vector of priorities of the base stations to slice1 
        du is a vector of delay utilities of uses of slice1, 
        ru is a vector of resource utilizations of users of slice1.
        (the same goes for slice2)
        '''
        max_users = np.random.randint(10, 600) # generate random users
        slice1 = Slice1(max_users)
        s1r, s1Q, s1ar, P1, du, ru = slice1.initSlice()# generating random users and and creating the network for slice1
        slice2 = Slice2(max_users)
        s2r, s2Q, s2ar, P2, rtu, rsu = slice2.initSlice()
        
        #checking feasile users
        [S1,V,accept,S2,V2,accept2]=initialVR2.initial_VR2(s1r, s1ar + 1 / s1Q, s2r, s2Q)# filter users that cant be satisfied
        # S1 is ID of slice 1, v is a vector of fractions that is occupied in
        # the checking but not used here, accept is a vector showing whether
        # the corresponding users are accepted or not 1 means accepted 0 means
        # not accepted, THE SAME GOES FOR SLCIE2

        if S1 > 0 and S2 > 0: # removing the users that are not in range
            [K1,B]=np.array(s1r).shape
            tr=np.zeros((K1,B))
            for k in range(0, K1):
                for b in range(0, B):
                    tr[k,b]=s1r[k,b] * accept[0,k] # if accept(1,k)=1 the users rate is saved, else it is set to zero
            
            rt=tr
            rt=rt[~(rt==0).all(1)]# remove the users with zero rate
            Dc=s1Q * accept # if user not accepted set its delay constraint to zero for removing
            Dc=np.delete(Dc, np.argwhere(np.all(Dc[..., :] == 0, axis=0)), axis=1)#Dc=Dc[0,any(Dc,1)]# removing the delay constrained of the users removed above

            ar=s1ar * accept# remove the arrival rate of the removed users
            ar=np.delete(ar, np.argwhere(np.all(ar[..., :] == 0, axis=0)), axis=1)#ar=ar[0,any(ar,1)]
            K1a=np.array(rt).shape[0]# accepted users of k1
            print('#d of #d users of slice1 accepted\n', K1a, K1)
            [K2,B]=np.array(s2r).shape
            tr2=np.zeros((K2,B))# the same steps for slice2
            for k in range(0, K2):
                for b in range(0, B):
                    tr2[k,b] = s2r(k,b) * accept2[0,k]

            rt2=tr2
            rt2=rt2[~(rt2==0).all(1)]
            Rc=s2Q * accept2
            Rc = np.delete(Rc, np.argwhere(np.all(Rc[..., :] == 0, axis=0)), axis=1) # Rc=Rc(1, any(Rc,1))
            ar2=s2ar * accept2
            ar2 = np.delete(ar2, np.argwhere(np.all(ar2[..., :] == 0, axis=0)), axis=1) #ar2=ar2(1,any(ar2,1))
            K2a=np.array(rt2).shape[0]# accepted users of k1

            print('#d of #d users of slice2 accepted\n',K2a,K2)
            cng1=0
            cng2=0
            # to calculate the resource requirements and priorities of the slice1
            Pu1=np.zeros((K1a,B))# minimum data link requirement of each user in each base station
            for u in range(0, K1a):
                Pu1[u,:]=(ar[0,u]+1/Dc[0,u]) * (rt[u,:] / sum(rt[u,:]))#equation12 and 13
            
            Puu1=sum(Pu1)
            P1=np.zeros((1,B))
            for bp2 in range(0, B):
                P1[0,bp2]=Puu1[0,bp2] / sum(Puu1)# priority or importance of the base stations to slice1
            
            reser = Reservation(S1,np.zeros((1,B)),Puu1)# minimim resource requirement os the slice1 on the base stations
            reser.UpdateUnusedResource()

            d1=-1# if resource is zero delay must be initialized out of the delay range for convenience of calculating utility
            cdu=0# current delay utility initialization
            cru=0# current resource utilization of slice1

            # to calculate the resource requirements and priorities of the slice2
            Pu2=np.zeros((K2a,B))# minimum resource requirement of each user of slice2 in each base station
            for u in range(0, K2a):
                Pu2[u,:]=(Rc[0,u]) * (rt2[u,:] / sum(rt2[u,:]))#equation12 and 13
            
            Puu2=sum(Pu2)
            P2=np.zeros((1,B))
            for bp2 in range(0, B):
                P2[0,bp2]=Puu2[0,bp2] / sum(Puu2)# priority or importance of the base stations to slice2
            
            reser2 = Reservation(S2, np.zeros((1,B)),Puu2)#  minimim resource requirement os the slice2 on the base stations
            reser2.UpdateUnusedResource()
            r2=0# data rate of slice2
            crtu=0# current rate utility of slice2
            crsu=0# current resource utilizatin of slice2

            xtrn=np.random.randint(4, 10)# to decide at how many time intervals to train
            for ii in range(0, 50):
                #  V and V2 are useless here
                AL1, RE1 = Reservation(1).sendCurrAllocAndReservOfSlice()# request allocation and reservation of slice 1 from all base stations
                AL2,RE2 = Reservation(2).sendCurrAllocAndReservOfSlice()#............slice2....
                
                P1,du,ru,v,a1,d1 = Slice1(S1,V,P1,ii,rt,Dc,ar,cdu,cru,cng1,AL1,RE1).makeResourceManagement()# MAKE AUTONOMOUS RESOURCE MANAGEMENT IN SLICE1
                P2,rtu,rsu,v2,a2,r2 = Slice2(S2,V2,P2,ii,rt2,Rc,ar2,crtu,crsu,cng2,AL2,RE2).makeResourceManagement()# MAKE AUTOMOUS RESOURCE MANAGEMET IN SLICE2
                # P1 avector importance of the base stations to slice1, 
                # du delay utility vector of the users of slice1, 
                # ru resource utility vector of the users of slice1, v the resource updated by the action in
                # slice1, a1 the action of slice1, 
                # d1 the delay vector for users of slice1, s1 is ID of slice1, V is use less here, 
                # ii is the current iteration of slicing time, 
                # rt is the data rate matrix for all users of slice one in all base stations, 
                # Dc is delay constraint of slice1, 
                # ar is arrival rate of slic1, cdu is currrent delay utility, 
                # cru is current resouce utility, 
                # AL1 is the previous resource allocation vector of slice1, 
                # RE1 is the current resource reservation vector of slice1 in all base stations.
                # the same goes for slice2... 
                # r2 is the rate vector of the users of slice2

                K1a=np.array(rt).shape[0]
                K2a=np.array(rt2).shape[0]  

                if ii > 1: # if the iteration is not initial calculate the reward functions and call the DQN for trdaining, and increament the number of users at an interval of three iterations
                    trn=0
                    #if a condition to trian IS ACTIVATED TRAIN THE ANN
                    if np.mod(ii, xtrn) == 0:
                        trn=1

                    #calculate reward of slice1
                    rw1=(sum(du[0,0:K1a])/K1a+9.*sum(ru[0,0:K1a])/K1a)/10# priority is given to the resource utility than the qos utility
                    #calculate the current state tuple of slice 1
                    cs1=[sum(AL1 * P1), sum(cdu)/K1a, sum(cru)/K1a, sum(RE1*P1)]
                    DQNd(cs1,a1,rw1,trn) # send the tuple to reply memory of
                    #slice 1 for training
                    #calculate reward of slice2
                    rw2=(sum(rtu[0, 0:K2a])/K2a+9.*sum(rsu[0,0:K2a])/K2a)/10# priority is given to the resource utility than qos utility
                    #calculate the current state tuple of slice 1
                    cs2=[sum(AL2*P2), sum(crtu)/K2a, sum(crsu)/K2a, sum(RE2*P2)]
                    DQNr(cs2,a2,rw2,trn)#  send the tuple to reply memory of
                    #slice 2 for training
                    #copy the next states
                    crtu=rtu
                    crsu=rsu
                else:
                    # save the calculated QOS utilities and resource utilizations
                    # as current states
                        cdu=du
                        cru=ru
                        crtu=rtu
                        crsu=rsu

                cng1=0
                cng2=0






        else:
            print('one or both of the slices not accepted')

        slice1.removeSliceFromResourceTable(S1,0)# remove slice 1 from resource table
        slice2.removeSliceFromResourceTable(S2,0)# remove slice2 from resource table   




if __name__ == "__main__":
    
    run()