'''
    This is used to check whether the users randomly generated by the slices
    are feasible in their resource requirement. they are first admited to the network using MAX SINR, 
    if fully accepted their accept=1 for that users else accept=0, 
    user is addmited in this case does not mean the users must have resource
    allocation from that base station only, it is used only for checking if
    the resource is enouph for all users. if res=0 is returned the slice is accepted, if res is non zero it will be
    ID of the slice 
    V is the resource vector in the slices occupied by the slice, 
    accept is a vector of of 0 and 1 that indicate whether the corresponding user of the slice is accepted or not
    rtV is a matrix of achievable data rates of the users of the slice in all hte base stations,
    Q is minimum resource requirement of the users
'''
def initialVR(rtV, Q):
    [S,un] = Reservation.getUnusedResourceAndNumOfSlices()
    [K,B] = np.array(rtV).shape
    qyu = np.zeros((K,B))
    for i in range(0, K):
        for j in range(0, B):
            qyu[i,j]=Q[1,i]/rtV[i,j]# how much fractions is required by the users in each bs assuming single user base station associations
    #calculate the resource requitement of the slice in the BSs assumig every user is admitted sequencially as they come to the nearest BS
    VR=np.zeros((1, B))
    accepF=np.zeros((1, K))#how much percent of the user is accepted
    copyr=rtV
    wh=0
    while wh <= K*B:
        maxr=max(max(copyr))# the smallest user bs distance combination
        for i in range(0, K):
            for m in range(0, B):
                if copyr[i,m]==maxr and (accepF[0,i]+1) !=2: # plus one is used to ignore very small fraction
                    if un[1,m]>=qyu[i,m]*(1-accepF[0,i]) and qyu[i,m]>0 and un[1,m]>0:
                        VR[0,m]=VR[0,m]+qyu[i,m] * (1-accepF[0,i])
                        un[1,m]=un[1,m]-qyu[i,m] * (1-accepF[0,i])
                        accepF[0,i]=1
                    elif un[1,m]<qyu[i,m]*(1-accepF[0,i]) and  qyu[i,m]>0 and un[1,m]>0:
                        VR[0,m]=VR[0,m]+un[1,m]
                        un[1,m]=0
                        accepF[0,i]=accepF[0,i]+un[1,m]/(qyu[i,m]*(1-accepF[0,i]))

                    copyr[i,m]=0
        
        if max(max(copyr))==0 or min(accepF)==1:
            break

        wh=wh+1
    
    # now the virtual resource is for the users that are fully accepted
    accept=np.floor(accepF)
    if sum(accept)>=1: # check if there is at leasst one user fully accepted
        S, _ = Reservation.getUnusedResourceAndNumOfSlices() 
        res=S+1
        V=VR
        RQ=np.zeros((1,B))
        reser = Reservation(res,np.zeros((1,B)), RQ, 0)
        reser.initialization()
    else:
        res=0 # reject the slice. no enouph resource
        V=np.zeros((1,B))


    return res, V, accept

